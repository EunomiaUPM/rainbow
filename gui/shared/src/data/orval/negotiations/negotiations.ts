/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Rainbow Frontend Gateway API
 * OpenAPI specification for the Rainbow Frontend Gateway.
The gateway proxies requests from the GUI to backend microservices.
All paths are prefixed with `/api` and routed by service prefix to the
corresponding microservice (catalog-agent, negotiation-agent, transfer-agent, auth-agent).

 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AgreementDto,
  ErrorInfo,
  NegotiationMessageDto,
  NegotiationProcessDto,
  OfferDto
} from '.././model';

import { customInstance } from '../../orval-mutator';
import type { ErrorType , BodyType } from '../../orval-mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List all negotiation processes
 */
export type getNegotiationProcessesResponse200 = {
  data: NegotiationProcessDto[]
  status: 200
}

export type getNegotiationProcessesResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getNegotiationProcessesResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getNegotiationProcessesResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getNegotiationProcessesResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getNegotiationProcessesResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getNegotiationProcessesResponseSuccess = (getNegotiationProcessesResponse200) & {
  headers: Headers;
};
export type getNegotiationProcessesResponseError = (getNegotiationProcessesResponse400 | getNegotiationProcessesResponse401 | getNegotiationProcessesResponse403 | getNegotiationProcessesResponse404 | getNegotiationProcessesResponse500) & {
  headers: Headers;
};

export type getNegotiationProcessesResponse = (getNegotiationProcessesResponseSuccess | getNegotiationProcessesResponseError)

export const getGetNegotiationProcessesUrl = () => {


  

  return `/negotiations/negotiation-processes`
}

export const getNegotiationProcesses = async ( options?: RequestInit): Promise<getNegotiationProcessesResponse> => {
  
  return customInstance<getNegotiationProcessesResponse>(getGetNegotiationProcessesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNegotiationProcessesInfiniteQueryKey = () => {
    return [
    'infinite', `/negotiations/negotiation-processes`
    ] as const;
    }

export const getGetNegotiationProcessesQueryKey = () => {
    return [
    `/negotiations/negotiation-processes`
    ] as const;
    }

    
export const getGetNegotiationProcessesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcesses>>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationProcessesInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationProcesses>>> = ({ signal }) => getNegotiationProcesses({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationProcessesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationProcesses>>>
export type GetNegotiationProcessesInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcesses>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcesses>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all negotiation processes
 */

export function useGetNegotiationProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationProcessesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetNegotiationProcessesQueryOptions = <TData = Awaited<ReturnType<typeof getNegotiationProcesses>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationProcessesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationProcesses>>> = ({ signal }) => getNegotiationProcesses({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationProcessesQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationProcesses>>>
export type GetNegotiationProcessesQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationProcesses<TData = Awaited<ReturnType<typeof getNegotiationProcesses>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcesses>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcesses<TData = Awaited<ReturnType<typeof getNegotiationProcesses>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcesses>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcesses<TData = Awaited<ReturnType<typeof getNegotiationProcesses>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all negotiation processes
 */

export function useGetNegotiationProcesses<TData = Awaited<ReturnType<typeof getNegotiationProcesses>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationProcessesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Create a negotiation process
 */
export type createNegotiationProcessResponse201 = {
  data: void
  status: 201
}

export type createNegotiationProcessResponse400 = {
  data: ErrorInfo
  status: 400
}

export type createNegotiationProcessResponse401 = {
  data: ErrorInfo
  status: 401
}

export type createNegotiationProcessResponse403 = {
  data: ErrorInfo
  status: 403
}

export type createNegotiationProcessResponse404 = {
  data: ErrorInfo
  status: 404
}

export type createNegotiationProcessResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type createNegotiationProcessResponseSuccess = (createNegotiationProcessResponse201) & {
  headers: Headers;
};
export type createNegotiationProcessResponseError = (createNegotiationProcessResponse400 | createNegotiationProcessResponse401 | createNegotiationProcessResponse403 | createNegotiationProcessResponse404 | createNegotiationProcessResponse500) & {
  headers: Headers;
};

export type createNegotiationProcessResponse = (createNegotiationProcessResponseSuccess | createNegotiationProcessResponseError)

export const getCreateNegotiationProcessUrl = () => {


  

  return `/negotiations/negotiation-processes`
}

export const createNegotiationProcess = async (negotiationProcessDto: NegotiationProcessDto, options?: RequestInit): Promise<createNegotiationProcessResponse> => {
  
  return customInstance<createNegotiationProcessResponse>(getCreateNegotiationProcessUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      negotiationProcessDto,)
  }
);}




export const getCreateNegotiationProcessMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNegotiationProcess>>, TError,{data: BodyType<NegotiationProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNegotiationProcess>>, TError,{data: BodyType<NegotiationProcessDto>}, TContext> => {

const mutationKey = ['createNegotiationProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNegotiationProcess>>, {data: BodyType<NegotiationProcessDto>}> = (props) => {
          const {data} = props ?? {};

          return  createNegotiationProcess(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNegotiationProcessMutationResult = NonNullable<Awaited<ReturnType<typeof createNegotiationProcess>>>
    export type CreateNegotiationProcessMutationBody = BodyType<NegotiationProcessDto>
    export type CreateNegotiationProcessMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Create a negotiation process
 */
export const useCreateNegotiationProcess = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNegotiationProcess>>, TError,{data: BodyType<NegotiationProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createNegotiationProcess>>,
        TError,
        {data: BodyType<NegotiationProcessDto>},
        TContext
      > => {
      return useMutation(getCreateNegotiationProcessMutationOptions(options), queryClient);
    }
    /**
 * @summary Get negotiation process by ID
 */
export type getNegotiationProcessByIdResponse200 = {
  data: NegotiationProcessDto
  status: 200
}

export type getNegotiationProcessByIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getNegotiationProcessByIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getNegotiationProcessByIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getNegotiationProcessByIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getNegotiationProcessByIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getNegotiationProcessByIdResponseSuccess = (getNegotiationProcessByIdResponse200) & {
  headers: Headers;
};
export type getNegotiationProcessByIdResponseError = (getNegotiationProcessByIdResponse400 | getNegotiationProcessByIdResponse401 | getNegotiationProcessByIdResponse403 | getNegotiationProcessByIdResponse404 | getNegotiationProcessByIdResponse500) & {
  headers: Headers;
};

export type getNegotiationProcessByIdResponse = (getNegotiationProcessByIdResponseSuccess | getNegotiationProcessByIdResponseError)

export const getGetNegotiationProcessByIdUrl = (processId: string,) => {


  

  return `/negotiations/negotiation-processes/${processId}`
}

export const getNegotiationProcessById = async (processId: string, options?: RequestInit): Promise<getNegotiationProcessByIdResponse> => {
  
  return customInstance<getNegotiationProcessByIdResponse>(getGetNegotiationProcessByIdUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNegotiationProcessByIdInfiniteQueryKey = (processId: string,) => {
    return [
    'infinite', `/negotiations/negotiation-processes/${processId}`
    ] as const;
    }

export const getGetNegotiationProcessByIdQueryKey = (processId: string,) => {
    return [
    `/negotiations/negotiation-processes/${processId}`
    ] as const;
    }

    
export const getGetNegotiationProcessByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcessById>>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationProcessByIdInfiniteQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationProcessById>>> = ({ signal }) => getNegotiationProcessById(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationProcessByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationProcessById>>>
export type GetNegotiationProcessByIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcessById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcessById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get negotiation process by ID
 */

export function useGetNegotiationProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationProcessByIdInfiniteQueryOptions(processId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetNegotiationProcessByIdQueryOptions = <TData = Awaited<ReturnType<typeof getNegotiationProcessById>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationProcessByIdQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationProcessById>>> = ({ signal }) => getNegotiationProcessById(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationProcessByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationProcessById>>>
export type GetNegotiationProcessByIdQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationProcessById<TData = Awaited<ReturnType<typeof getNegotiationProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcessById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcessById<TData = Awaited<ReturnType<typeof getNegotiationProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationProcessById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationProcessById<TData = Awaited<ReturnType<typeof getNegotiationProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get negotiation process by ID
 */

export function useGetNegotiationProcessById<TData = Awaited<ReturnType<typeof getNegotiationProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationProcessByIdQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update a negotiation process
 */
export type updateNegotiationProcessResponse200 = {
  data: void
  status: 200
}

export type updateNegotiationProcessResponse400 = {
  data: ErrorInfo
  status: 400
}

export type updateNegotiationProcessResponse401 = {
  data: ErrorInfo
  status: 401
}

export type updateNegotiationProcessResponse403 = {
  data: ErrorInfo
  status: 403
}

export type updateNegotiationProcessResponse404 = {
  data: ErrorInfo
  status: 404
}

export type updateNegotiationProcessResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type updateNegotiationProcessResponseSuccess = (updateNegotiationProcessResponse200) & {
  headers: Headers;
};
export type updateNegotiationProcessResponseError = (updateNegotiationProcessResponse400 | updateNegotiationProcessResponse401 | updateNegotiationProcessResponse403 | updateNegotiationProcessResponse404 | updateNegotiationProcessResponse500) & {
  headers: Headers;
};

export type updateNegotiationProcessResponse = (updateNegotiationProcessResponseSuccess | updateNegotiationProcessResponseError)

export const getUpdateNegotiationProcessUrl = (processId: string,) => {


  

  return `/negotiations/negotiation-processes/${processId}`
}

export const updateNegotiationProcess = async (processId: string,
    negotiationProcessDto: NegotiationProcessDto, options?: RequestInit): Promise<updateNegotiationProcessResponse> => {
  
  return customInstance<updateNegotiationProcessResponse>(getUpdateNegotiationProcessUrl(processId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      negotiationProcessDto,)
  }
);}




export const getUpdateNegotiationProcessMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNegotiationProcess>>, TError,{processId: string;data: BodyType<NegotiationProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNegotiationProcess>>, TError,{processId: string;data: BodyType<NegotiationProcessDto>}, TContext> => {

const mutationKey = ['updateNegotiationProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNegotiationProcess>>, {processId: string;data: BodyType<NegotiationProcessDto>}> = (props) => {
          const {processId,data} = props ?? {};

          return  updateNegotiationProcess(processId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNegotiationProcessMutationResult = NonNullable<Awaited<ReturnType<typeof updateNegotiationProcess>>>
    export type UpdateNegotiationProcessMutationBody = BodyType<NegotiationProcessDto>
    export type UpdateNegotiationProcessMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Update a negotiation process
 */
export const useUpdateNegotiationProcess = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNegotiationProcess>>, TError,{processId: string;data: BodyType<NegotiationProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateNegotiationProcess>>,
        TError,
        {processId: string;data: BodyType<NegotiationProcessDto>},
        TContext
      > => {
      return useMutation(getUpdateNegotiationProcessMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete a negotiation process
 */
export type deleteNegotiationProcessResponse204 = {
  data: void
  status: 204
}

export type deleteNegotiationProcessResponse400 = {
  data: ErrorInfo
  status: 400
}

export type deleteNegotiationProcessResponse401 = {
  data: ErrorInfo
  status: 401
}

export type deleteNegotiationProcessResponse403 = {
  data: ErrorInfo
  status: 403
}

export type deleteNegotiationProcessResponse404 = {
  data: ErrorInfo
  status: 404
}

export type deleteNegotiationProcessResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type deleteNegotiationProcessResponseSuccess = (deleteNegotiationProcessResponse204) & {
  headers: Headers;
};
export type deleteNegotiationProcessResponseError = (deleteNegotiationProcessResponse400 | deleteNegotiationProcessResponse401 | deleteNegotiationProcessResponse403 | deleteNegotiationProcessResponse404 | deleteNegotiationProcessResponse500) & {
  headers: Headers;
};

export type deleteNegotiationProcessResponse = (deleteNegotiationProcessResponseSuccess | deleteNegotiationProcessResponseError)

export const getDeleteNegotiationProcessUrl = (processId: string,) => {


  

  return `/negotiations/negotiation-processes/${processId}`
}

export const deleteNegotiationProcess = async (processId: string, options?: RequestInit): Promise<deleteNegotiationProcessResponse> => {
  
  return customInstance<deleteNegotiationProcessResponse>(getDeleteNegotiationProcessUrl(processId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteNegotiationProcessMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNegotiationProcess>>, TError,{processId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNegotiationProcess>>, TError,{processId: string}, TContext> => {

const mutationKey = ['deleteNegotiationProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNegotiationProcess>>, {processId: string}> = (props) => {
          const {processId} = props ?? {};

          return  deleteNegotiationProcess(processId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNegotiationProcessMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNegotiationProcess>>>
    
    export type DeleteNegotiationProcessMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Delete a negotiation process
 */
export const useDeleteNegotiationProcess = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNegotiationProcess>>, TError,{processId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNegotiationProcess>>,
        TError,
        {processId: string},
        TContext
      > => {
      return useMutation(getDeleteNegotiationProcessMutationOptions(options), queryClient);
    }
    /**
 * @summary List messages for a negotiation process
 */
export type getNegotiationMessagesByProcessIdResponse200 = {
  data: NegotiationMessageDto[]
  status: 200
}

export type getNegotiationMessagesByProcessIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getNegotiationMessagesByProcessIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getNegotiationMessagesByProcessIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getNegotiationMessagesByProcessIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getNegotiationMessagesByProcessIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getNegotiationMessagesByProcessIdResponseSuccess = (getNegotiationMessagesByProcessIdResponse200) & {
  headers: Headers;
};
export type getNegotiationMessagesByProcessIdResponseError = (getNegotiationMessagesByProcessIdResponse400 | getNegotiationMessagesByProcessIdResponse401 | getNegotiationMessagesByProcessIdResponse403 | getNegotiationMessagesByProcessIdResponse404 | getNegotiationMessagesByProcessIdResponse500) & {
  headers: Headers;
};

export type getNegotiationMessagesByProcessIdResponse = (getNegotiationMessagesByProcessIdResponseSuccess | getNegotiationMessagesByProcessIdResponseError)

export const getGetNegotiationMessagesByProcessIdUrl = (processId: string,) => {


  

  return `/negotiations/negotiation-messages/process/${processId}`
}

export const getNegotiationMessagesByProcessId = async (processId: string, options?: RequestInit): Promise<getNegotiationMessagesByProcessIdResponse> => {
  
  return customInstance<getNegotiationMessagesByProcessIdResponse>(getGetNegotiationMessagesByProcessIdUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNegotiationMessagesByProcessIdInfiniteQueryKey = (processId: string,) => {
    return [
    'infinite', `/negotiations/negotiation-messages/process/${processId}`
    ] as const;
    }

export const getGetNegotiationMessagesByProcessIdQueryKey = (processId: string,) => {
    return [
    `/negotiations/negotiation-messages/process/${processId}`
    ] as const;
    }

    
export const getGetNegotiationMessagesByProcessIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationMessagesByProcessIdInfiniteQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>> = ({ signal }) => getNegotiationMessagesByProcessId(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationMessagesByProcessIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>
export type GetNegotiationMessagesByProcessIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List messages for a negotiation process
 */

export function useGetNegotiationMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationMessagesByProcessIdInfiniteQueryOptions(processId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetNegotiationMessagesByProcessIdQueryOptions = <TData = Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationMessagesByProcessIdQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>> = ({ signal }) => getNegotiationMessagesByProcessId(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationMessagesByProcessIdQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>>
export type GetNegotiationMessagesByProcessIdQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationMessagesByProcessId<TData = Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessagesByProcessId<TData = Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessagesByProcessId<TData = Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List messages for a negotiation process
 */

export function useGetNegotiationMessagesByProcessId<TData = Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationMessagesByProcessIdQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get a negotiation message by ID
 */
export type getNegotiationMessageByIdResponse200 = {
  data: NegotiationMessageDto
  status: 200
}

export type getNegotiationMessageByIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getNegotiationMessageByIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getNegotiationMessageByIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getNegotiationMessageByIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getNegotiationMessageByIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getNegotiationMessageByIdResponseSuccess = (getNegotiationMessageByIdResponse200) & {
  headers: Headers;
};
export type getNegotiationMessageByIdResponseError = (getNegotiationMessageByIdResponse400 | getNegotiationMessageByIdResponse401 | getNegotiationMessageByIdResponse403 | getNegotiationMessageByIdResponse404 | getNegotiationMessageByIdResponse500) & {
  headers: Headers;
};

export type getNegotiationMessageByIdResponse = (getNegotiationMessageByIdResponseSuccess | getNegotiationMessageByIdResponseError)

export const getGetNegotiationMessageByIdUrl = (messageId: string,) => {


  

  return `/negotiations/negotiation-messages/${messageId}`
}

export const getNegotiationMessageById = async (messageId: string, options?: RequestInit): Promise<getNegotiationMessageByIdResponse> => {
  
  return customInstance<getNegotiationMessageByIdResponse>(getGetNegotiationMessageByIdUrl(messageId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNegotiationMessageByIdInfiniteQueryKey = (messageId: string,) => {
    return [
    'infinite', `/negotiations/negotiation-messages/${messageId}`
    ] as const;
    }

export const getGetNegotiationMessageByIdQueryKey = (messageId: string,) => {
    return [
    `/negotiations/negotiation-messages/${messageId}`
    ] as const;
    }

    
export const getGetNegotiationMessageByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessageById>>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationMessageByIdInfiniteQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationMessageById>>> = ({ signal }) => getNegotiationMessageById(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationMessageByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationMessageById>>>
export type GetNegotiationMessageByIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessageById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessageById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a negotiation message by ID
 */

export function useGetNegotiationMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNegotiationMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationMessageByIdInfiniteQueryOptions(messageId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetNegotiationMessageByIdQueryOptions = <TData = Awaited<ReturnType<typeof getNegotiationMessageById>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNegotiationMessageByIdQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNegotiationMessageById>>> = ({ signal }) => getNegotiationMessageById(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNegotiationMessageByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getNegotiationMessageById>>>
export type GetNegotiationMessageByIdQueryError = ErrorType<ErrorInfo>


export function useGetNegotiationMessageById<TData = Awaited<ReturnType<typeof getNegotiationMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessageById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessageById<TData = Awaited<ReturnType<typeof getNegotiationMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNegotiationMessageById>>,
          TError,
          Awaited<ReturnType<typeof getNegotiationMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNegotiationMessageById<TData = Awaited<ReturnType<typeof getNegotiationMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a negotiation message by ID
 */

export function useGetNegotiationMessageById<TData = Awaited<ReturnType<typeof getNegotiationMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNegotiationMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNegotiationMessageByIdQueryOptions(messageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get the offer attached to a negotiation message
 */
export type getOfferByMessageIdResponse200 = {
  data: OfferDto
  status: 200
}

export type getOfferByMessageIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getOfferByMessageIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getOfferByMessageIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getOfferByMessageIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getOfferByMessageIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getOfferByMessageIdResponseSuccess = (getOfferByMessageIdResponse200) & {
  headers: Headers;
};
export type getOfferByMessageIdResponseError = (getOfferByMessageIdResponse400 | getOfferByMessageIdResponse401 | getOfferByMessageIdResponse403 | getOfferByMessageIdResponse404 | getOfferByMessageIdResponse500) & {
  headers: Headers;
};

export type getOfferByMessageIdResponse = (getOfferByMessageIdResponseSuccess | getOfferByMessageIdResponseError)

export const getGetOfferByMessageIdUrl = (messageId: string,) => {


  

  return `/negotiations/offers/message/${messageId}`
}

export const getOfferByMessageId = async (messageId: string, options?: RequestInit): Promise<getOfferByMessageIdResponse> => {
  
  return customInstance<getOfferByMessageIdResponse>(getGetOfferByMessageIdUrl(messageId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOfferByMessageIdInfiniteQueryKey = (messageId: string,) => {
    return [
    'infinite', `/negotiations/offers/message/${messageId}`
    ] as const;
    }

export const getGetOfferByMessageIdQueryKey = (messageId: string,) => {
    return [
    `/negotiations/offers/message/${messageId}`
    ] as const;
    }

    
export const getGetOfferByMessageIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOfferByMessageId>>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOfferByMessageIdInfiniteQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOfferByMessageId>>> = ({ signal }) => getOfferByMessageId(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOfferByMessageIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOfferByMessageId>>>
export type GetOfferByMessageIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetOfferByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOfferByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOfferByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getOfferByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOfferByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOfferByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOfferByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getOfferByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOfferByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOfferByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the offer attached to a negotiation message
 */

export function useGetOfferByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOfferByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetOfferByMessageIdInfiniteQueryOptions(messageId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetOfferByMessageIdQueryOptions = <TData = Awaited<ReturnType<typeof getOfferByMessageId>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOfferByMessageIdQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOfferByMessageId>>> = ({ signal }) => getOfferByMessageId(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOfferByMessageIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOfferByMessageId>>>
export type GetOfferByMessageIdQueryError = ErrorType<ErrorInfo>


export function useGetOfferByMessageId<TData = Awaited<ReturnType<typeof getOfferByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOfferByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getOfferByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOfferByMessageId<TData = Awaited<ReturnType<typeof getOfferByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOfferByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getOfferByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOfferByMessageId<TData = Awaited<ReturnType<typeof getOfferByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the offer attached to a negotiation message
 */

export function useGetOfferByMessageId<TData = Awaited<ReturnType<typeof getOfferByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOfferByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetOfferByMessageIdQueryOptions(messageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get offers for a negotiation process (last offer)
 */
export type getOffersByProcessIdResponse200 = {
  data: OfferDto[]
  status: 200
}

export type getOffersByProcessIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getOffersByProcessIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getOffersByProcessIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getOffersByProcessIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getOffersByProcessIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getOffersByProcessIdResponseSuccess = (getOffersByProcessIdResponse200) & {
  headers: Headers;
};
export type getOffersByProcessIdResponseError = (getOffersByProcessIdResponse400 | getOffersByProcessIdResponse401 | getOffersByProcessIdResponse403 | getOffersByProcessIdResponse404 | getOffersByProcessIdResponse500) & {
  headers: Headers;
};

export type getOffersByProcessIdResponse = (getOffersByProcessIdResponseSuccess | getOffersByProcessIdResponseError)

export const getGetOffersByProcessIdUrl = (processId: string,) => {


  

  return `/negotiations/offers/process/${processId}`
}

export const getOffersByProcessId = async (processId: string, options?: RequestInit): Promise<getOffersByProcessIdResponse> => {
  
  return customInstance<getOffersByProcessIdResponse>(getGetOffersByProcessIdUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetOffersByProcessIdInfiniteQueryKey = (processId: string,) => {
    return [
    'infinite', `/negotiations/offers/process/${processId}`
    ] as const;
    }

export const getGetOffersByProcessIdQueryKey = (processId: string,) => {
    return [
    `/negotiations/offers/process/${processId}`
    ] as const;
    }

    
export const getGetOffersByProcessIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOffersByProcessId>>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOffersByProcessIdInfiniteQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOffersByProcessId>>> = ({ signal }) => getOffersByProcessId(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOffersByProcessIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOffersByProcessId>>>
export type GetOffersByProcessIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetOffersByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOffersByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOffersByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getOffersByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOffersByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOffersByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOffersByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getOffersByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOffersByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOffersByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get offers for a negotiation process (last offer)
 */

export function useGetOffersByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOffersByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetOffersByProcessIdInfiniteQueryOptions(processId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetOffersByProcessIdQueryOptions = <TData = Awaited<ReturnType<typeof getOffersByProcessId>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOffersByProcessIdQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOffersByProcessId>>> = ({ signal }) => getOffersByProcessId(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOffersByProcessIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOffersByProcessId>>>
export type GetOffersByProcessIdQueryError = ErrorType<ErrorInfo>


export function useGetOffersByProcessId<TData = Awaited<ReturnType<typeof getOffersByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOffersByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getOffersByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOffersByProcessId<TData = Awaited<ReturnType<typeof getOffersByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOffersByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getOffersByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOffersByProcessId<TData = Awaited<ReturnType<typeof getOffersByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get offers for a negotiation process (last offer)
 */

export function useGetOffersByProcessId<TData = Awaited<ReturnType<typeof getOffersByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOffersByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetOffersByProcessIdQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary List all agreements
 */
export type getAgreementsResponse200 = {
  data: AgreementDto[]
  status: 200
}

export type getAgreementsResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getAgreementsResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getAgreementsResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getAgreementsResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getAgreementsResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getAgreementsResponseSuccess = (getAgreementsResponse200) & {
  headers: Headers;
};
export type getAgreementsResponseError = (getAgreementsResponse400 | getAgreementsResponse401 | getAgreementsResponse403 | getAgreementsResponse404 | getAgreementsResponse500) & {
  headers: Headers;
};

export type getAgreementsResponse = (getAgreementsResponseSuccess | getAgreementsResponseError)

export const getGetAgreementsUrl = () => {


  

  return `/negotiations/agreements`
}

export const getAgreements = async ( options?: RequestInit): Promise<getAgreementsResponse> => {
  
  return customInstance<getAgreementsResponse>(getGetAgreementsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAgreementsInfiniteQueryKey = () => {
    return [
    'infinite', `/negotiations/agreements`
    ] as const;
    }

export const getGetAgreementsQueryKey = () => {
    return [
    `/negotiations/agreements`
    ] as const;
    }

    
export const getGetAgreementsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAgreements>>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementsInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreements>>> = ({ signal }) => getAgreements({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreements>>>
export type GetAgreementsInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetAgreementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreements>>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreements>>,
          TError,
          Awaited<ReturnType<typeof getAgreements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreements>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreements>>,
          TError,
          Awaited<ReturnType<typeof getAgreements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreements>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all agreements
 */

export function useGetAgreementsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreements>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAgreementsQueryOptions = <TData = Awaited<ReturnType<typeof getAgreements>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreements>>> = ({ signal }) => getAgreements({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementsQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreements>>>
export type GetAgreementsQueryError = ErrorType<ErrorInfo>


export function useGetAgreements<TData = Awaited<ReturnType<typeof getAgreements>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreements>>,
          TError,
          Awaited<ReturnType<typeof getAgreements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreements<TData = Awaited<ReturnType<typeof getAgreements>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreements>>,
          TError,
          Awaited<ReturnType<typeof getAgreements>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreements<TData = Awaited<ReturnType<typeof getAgreements>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all agreements
 */

export function useGetAgreements<TData = Awaited<ReturnType<typeof getAgreements>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreements>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get agreement by ID
 */
export type getAgreementByIdSResponse200 = {
  data: AgreementDto
  status: 200
}

export type getAgreementByIdSResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getAgreementByIdSResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getAgreementByIdSResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getAgreementByIdSResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getAgreementByIdSResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getAgreementByIdSResponseSuccess = (getAgreementByIdSResponse200) & {
  headers: Headers;
};
export type getAgreementByIdSResponseError = (getAgreementByIdSResponse400 | getAgreementByIdSResponse401 | getAgreementByIdSResponse403 | getAgreementByIdSResponse404 | getAgreementByIdSResponse500) & {
  headers: Headers;
};

export type getAgreementByIdSResponse = (getAgreementByIdSResponseSuccess | getAgreementByIdSResponseError)

export const getGetAgreementByIdSUrl = (agreementId: string,) => {


  

  return `/negotiations/agreements/${agreementId}`
}

export const getAgreementByIdS = async (agreementId: string, options?: RequestInit): Promise<getAgreementByIdSResponse> => {
  
  return customInstance<getAgreementByIdSResponse>(getGetAgreementByIdSUrl(agreementId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAgreementByIdSInfiniteQueryKey = (agreementId: string,) => {
    return [
    'infinite', `/negotiations/agreements/${agreementId}`
    ] as const;
    }

export const getGetAgreementByIdSQueryKey = (agreementId: string,) => {
    return [
    `/negotiations/agreements/${agreementId}`
    ] as const;
    }

    
export const getGetAgreementByIdSInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByIdS>>>, TError = ErrorType<ErrorInfo>>(agreementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementByIdSInfiniteQueryKey(agreementId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreementByIdS>>> = ({ signal }) => getAgreementByIdS(agreementId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(agreementId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementByIdSInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreementByIdS>>>
export type GetAgreementByIdSInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetAgreementByIdSInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByIdS>>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByIdS>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByIdS>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByIdSInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByIdS>>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByIdS>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByIdS>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByIdSInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByIdS>>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get agreement by ID
 */

export function useGetAgreementByIdSInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByIdS>>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementByIdSInfiniteQueryOptions(agreementId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAgreementByIdSQueryOptions = <TData = Awaited<ReturnType<typeof getAgreementByIdS>>, TError = ErrorType<ErrorInfo>>(agreementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementByIdSQueryKey(agreementId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreementByIdS>>> = ({ signal }) => getAgreementByIdS(agreementId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(agreementId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementByIdSQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreementByIdS>>>
export type GetAgreementByIdSQueryError = ErrorType<ErrorInfo>


export function useGetAgreementByIdS<TData = Awaited<ReturnType<typeof getAgreementByIdS>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByIdS>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByIdS>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByIdS<TData = Awaited<ReturnType<typeof getAgreementByIdS>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByIdS>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByIdS>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByIdS<TData = Awaited<ReturnType<typeof getAgreementByIdS>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get agreement by ID
 */

export function useGetAgreementByIdS<TData = Awaited<ReturnType<typeof getAgreementByIdS>>, TError = ErrorType<ErrorInfo>>(
 agreementId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByIdS>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementByIdSQueryOptions(agreementId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update an agreement
 */
export type updateAgreementResponse200 = {
  data: void
  status: 200
}

export type updateAgreementResponse400 = {
  data: ErrorInfo
  status: 400
}

export type updateAgreementResponse401 = {
  data: ErrorInfo
  status: 401
}

export type updateAgreementResponse403 = {
  data: ErrorInfo
  status: 403
}

export type updateAgreementResponse404 = {
  data: ErrorInfo
  status: 404
}

export type updateAgreementResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type updateAgreementResponseSuccess = (updateAgreementResponse200) & {
  headers: Headers;
};
export type updateAgreementResponseError = (updateAgreementResponse400 | updateAgreementResponse401 | updateAgreementResponse403 | updateAgreementResponse404 | updateAgreementResponse500) & {
  headers: Headers;
};

export type updateAgreementResponse = (updateAgreementResponseSuccess | updateAgreementResponseError)

export const getUpdateAgreementUrl = (agreementId: string,) => {


  

  return `/negotiations/agreements/${agreementId}`
}

export const updateAgreement = async (agreementId: string,
    agreementDto: AgreementDto, options?: RequestInit): Promise<updateAgreementResponse> => {
  
  return customInstance<updateAgreementResponse>(getUpdateAgreementUrl(agreementId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      agreementDto,)
  }
);}




export const getUpdateAgreementMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAgreement>>, TError,{agreementId: string;data: BodyType<AgreementDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAgreement>>, TError,{agreementId: string;data: BodyType<AgreementDto>}, TContext> => {

const mutationKey = ['updateAgreement'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAgreement>>, {agreementId: string;data: BodyType<AgreementDto>}> = (props) => {
          const {agreementId,data} = props ?? {};

          return  updateAgreement(agreementId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAgreementMutationResult = NonNullable<Awaited<ReturnType<typeof updateAgreement>>>
    export type UpdateAgreementMutationBody = BodyType<AgreementDto>
    export type UpdateAgreementMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Update an agreement
 */
export const useUpdateAgreement = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAgreement>>, TError,{agreementId: string;data: BodyType<AgreementDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAgreement>>,
        TError,
        {agreementId: string;data: BodyType<AgreementDto>},
        TContext
      > => {
      return useMutation(getUpdateAgreementMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete an agreement
 */
export type deleteAgreementResponse204 = {
  data: void
  status: 204
}

export type deleteAgreementResponse400 = {
  data: ErrorInfo
  status: 400
}

export type deleteAgreementResponse401 = {
  data: ErrorInfo
  status: 401
}

export type deleteAgreementResponse403 = {
  data: ErrorInfo
  status: 403
}

export type deleteAgreementResponse404 = {
  data: ErrorInfo
  status: 404
}

export type deleteAgreementResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type deleteAgreementResponseSuccess = (deleteAgreementResponse204) & {
  headers: Headers;
};
export type deleteAgreementResponseError = (deleteAgreementResponse400 | deleteAgreementResponse401 | deleteAgreementResponse403 | deleteAgreementResponse404 | deleteAgreementResponse500) & {
  headers: Headers;
};

export type deleteAgreementResponse = (deleteAgreementResponseSuccess | deleteAgreementResponseError)

export const getDeleteAgreementUrl = (agreementId: string,) => {


  

  return `/negotiations/agreements/${agreementId}`
}

export const deleteAgreement = async (agreementId: string, options?: RequestInit): Promise<deleteAgreementResponse> => {
  
  return customInstance<deleteAgreementResponse>(getDeleteAgreementUrl(agreementId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteAgreementMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAgreement>>, TError,{agreementId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAgreement>>, TError,{agreementId: string}, TContext> => {

const mutationKey = ['deleteAgreement'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAgreement>>, {agreementId: string}> = (props) => {
          const {agreementId} = props ?? {};

          return  deleteAgreement(agreementId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAgreementMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAgreement>>>
    
    export type DeleteAgreementMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Delete an agreement
 */
export const useDeleteAgreement = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAgreement>>, TError,{agreementId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAgreement>>,
        TError,
        {agreementId: string},
        TContext
      > => {
      return useMutation(getDeleteAgreementMutationOptions(options), queryClient);
    }
    /**
 * @summary Get agreement linked to a negotiation message
 */
export type getAgreementByMessageIdResponse200 = {
  data: AgreementDto
  status: 200
}

export type getAgreementByMessageIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getAgreementByMessageIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getAgreementByMessageIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getAgreementByMessageIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getAgreementByMessageIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getAgreementByMessageIdResponseSuccess = (getAgreementByMessageIdResponse200) & {
  headers: Headers;
};
export type getAgreementByMessageIdResponseError = (getAgreementByMessageIdResponse400 | getAgreementByMessageIdResponse401 | getAgreementByMessageIdResponse403 | getAgreementByMessageIdResponse404 | getAgreementByMessageIdResponse500) & {
  headers: Headers;
};

export type getAgreementByMessageIdResponse = (getAgreementByMessageIdResponseSuccess | getAgreementByMessageIdResponseError)

export const getGetAgreementByMessageIdUrl = (messageId: string,) => {


  

  return `/negotiations/agreements/message/${messageId}`
}

export const getAgreementByMessageId = async (messageId: string, options?: RequestInit): Promise<getAgreementByMessageIdResponse> => {
  
  return customInstance<getAgreementByMessageIdResponse>(getGetAgreementByMessageIdUrl(messageId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAgreementByMessageIdInfiniteQueryKey = (messageId: string,) => {
    return [
    'infinite', `/negotiations/agreements/message/${messageId}`
    ] as const;
    }

export const getGetAgreementByMessageIdQueryKey = (messageId: string,) => {
    return [
    `/negotiations/agreements/message/${messageId}`
    ] as const;
    }

    
export const getGetAgreementByMessageIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByMessageId>>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementByMessageIdInfiniteQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreementByMessageId>>> = ({ signal }) => getAgreementByMessageId(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementByMessageIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreementByMessageId>>>
export type GetAgreementByMessageIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetAgreementByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get agreement linked to a negotiation message
 */

export function useGetAgreementByMessageIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementByMessageId>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementByMessageIdInfiniteQueryOptions(messageId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAgreementByMessageIdQueryOptions = <TData = Awaited<ReturnType<typeof getAgreementByMessageId>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementByMessageIdQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreementByMessageId>>> = ({ signal }) => getAgreementByMessageId(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementByMessageIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreementByMessageId>>>
export type GetAgreementByMessageIdQueryError = ErrorType<ErrorInfo>


export function useGetAgreementByMessageId<TData = Awaited<ReturnType<typeof getAgreementByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByMessageId<TData = Awaited<ReturnType<typeof getAgreementByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementByMessageId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementByMessageId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementByMessageId<TData = Awaited<ReturnType<typeof getAgreementByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get agreement linked to a negotiation message
 */

export function useGetAgreementByMessageId<TData = Awaited<ReturnType<typeof getAgreementByMessageId>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementByMessageId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementByMessageIdQueryOptions(messageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get agreements by assigner participant
 */
export type getAgreementsByParticipantIdResponse200 = {
  data: AgreementDto[]
  status: 200
}

export type getAgreementsByParticipantIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getAgreementsByParticipantIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getAgreementsByParticipantIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getAgreementsByParticipantIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getAgreementsByParticipantIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getAgreementsByParticipantIdResponseSuccess = (getAgreementsByParticipantIdResponse200) & {
  headers: Headers;
};
export type getAgreementsByParticipantIdResponseError = (getAgreementsByParticipantIdResponse400 | getAgreementsByParticipantIdResponse401 | getAgreementsByParticipantIdResponse403 | getAgreementsByParticipantIdResponse404 | getAgreementsByParticipantIdResponse500) & {
  headers: Headers;
};

export type getAgreementsByParticipantIdResponse = (getAgreementsByParticipantIdResponseSuccess | getAgreementsByParticipantIdResponseError)

export const getGetAgreementsByParticipantIdUrl = (participantId: string,) => {


  

  return `/negotiations/agreements/assigner/${participantId}`
}

export const getAgreementsByParticipantId = async (participantId: string, options?: RequestInit): Promise<getAgreementsByParticipantIdResponse> => {
  
  return customInstance<getAgreementsByParticipantIdResponse>(getGetAgreementsByParticipantIdUrl(participantId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetAgreementsByParticipantIdInfiniteQueryKey = (participantId: string,) => {
    return [
    'infinite', `/negotiations/agreements/assigner/${participantId}`
    ] as const;
    }

export const getGetAgreementsByParticipantIdQueryKey = (participantId: string,) => {
    return [
    `/negotiations/agreements/assigner/${participantId}`
    ] as const;
    }

    
export const getGetAgreementsByParticipantIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>, TError = ErrorType<ErrorInfo>>(participantId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementsByParticipantIdInfiniteQueryKey(participantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreementsByParticipantId>>> = ({ signal }) => getAgreementsByParticipantId(participantId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(participantId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementsByParticipantIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>
export type GetAgreementsByParticipantIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetAgreementsByParticipantIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementsByParticipantIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementsByParticipantIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get agreements by assigner participant
 */

export function useGetAgreementsByParticipantIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementsByParticipantIdInfiniteQueryOptions(participantId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetAgreementsByParticipantIdQueryOptions = <TData = Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError = ErrorType<ErrorInfo>>(participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgreementsByParticipantIdQueryKey(participantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgreementsByParticipantId>>> = ({ signal }) => getAgreementsByParticipantId(participantId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(participantId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAgreementsByParticipantIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAgreementsByParticipantId>>>
export type GetAgreementsByParticipantIdQueryError = ErrorType<ErrorInfo>


export function useGetAgreementsByParticipantId<TData = Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementsByParticipantId<TData = Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>,
          TError,
          Awaited<ReturnType<typeof getAgreementsByParticipantId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAgreementsByParticipantId<TData = Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get agreements by assigner participant
 */

export function useGetAgreementsByParticipantId<TData = Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError = ErrorType<ErrorInfo>>(
 participantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgreementsByParticipantId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAgreementsByParticipantIdQueryOptions(participantId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




