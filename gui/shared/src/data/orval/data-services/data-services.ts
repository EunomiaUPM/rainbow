/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Rainbow Frontend Gateway API
 * OpenAPI specification for the Rainbow Frontend Gateway.
The gateway proxies requests from the GUI to backend microservices.
All paths are prefixed with `/api` and routed by service prefix to the
corresponding microservice (catalog-agent, negotiation-agent, transfer-agent, auth-agent).

 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DataServiceDto,
  ErrorInfo,
  NewDataServiceDto
} from '.././model';

import { customInstance } from '../../orval-mutator';
import type { ErrorType , BodyType } from '../../orval-mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create a data service
 */
export type createDataServiceResponse201 = {
  data: void
  status: 201
}

export type createDataServiceResponse400 = {
  data: ErrorInfo
  status: 400
}

export type createDataServiceResponse401 = {
  data: ErrorInfo
  status: 401
}

export type createDataServiceResponse403 = {
  data: ErrorInfo
  status: 403
}

export type createDataServiceResponse404 = {
  data: ErrorInfo
  status: 404
}

export type createDataServiceResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type createDataServiceResponseSuccess = (createDataServiceResponse201) & {
  headers: Headers;
};
export type createDataServiceResponseError = (createDataServiceResponse400 | createDataServiceResponse401 | createDataServiceResponse403 | createDataServiceResponse404 | createDataServiceResponse500) & {
  headers: Headers;
};

export type createDataServiceResponse = (createDataServiceResponseSuccess | createDataServiceResponseError)

export const getCreateDataServiceUrl = () => {


  

  return `/data-services`
}

export const createDataService = async (newDataServiceDto: NewDataServiceDto, options?: RequestInit): Promise<createDataServiceResponse> => {
  
  return customInstance<createDataServiceResponse>(getCreateDataServiceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      newDataServiceDto,)
  }
);}




export const getCreateDataServiceMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataService>>, TError,{data: BodyType<NewDataServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createDataService>>, TError,{data: BodyType<NewDataServiceDto>}, TContext> => {

const mutationKey = ['createDataService'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDataService>>, {data: BodyType<NewDataServiceDto>}> = (props) => {
          const {data} = props ?? {};

          return  createDataService(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDataServiceMutationResult = NonNullable<Awaited<ReturnType<typeof createDataService>>>
    export type CreateDataServiceMutationBody = BodyType<NewDataServiceDto>
    export type CreateDataServiceMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Create a data service
 */
export const useCreateDataService = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataService>>, TError,{data: BodyType<NewDataServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDataService>>,
        TError,
        {data: BodyType<NewDataServiceDto>},
        TContext
      > => {
      return useMutation(getCreateDataServiceMutationOptions(options), queryClient);
    }
    /**
 * @summary List data services by catalog
 */
export type getDataServicesByCatalogIdResponse200 = {
  data: DataServiceDto[]
  status: 200
}

export type getDataServicesByCatalogIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getDataServicesByCatalogIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getDataServicesByCatalogIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getDataServicesByCatalogIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getDataServicesByCatalogIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getDataServicesByCatalogIdResponseSuccess = (getDataServicesByCatalogIdResponse200) & {
  headers: Headers;
};
export type getDataServicesByCatalogIdResponseError = (getDataServicesByCatalogIdResponse400 | getDataServicesByCatalogIdResponse401 | getDataServicesByCatalogIdResponse403 | getDataServicesByCatalogIdResponse404 | getDataServicesByCatalogIdResponse500) & {
  headers: Headers;
};

export type getDataServicesByCatalogIdResponse = (getDataServicesByCatalogIdResponseSuccess | getDataServicesByCatalogIdResponseError)

export const getGetDataServicesByCatalogIdUrl = (catalogId: string,) => {


  

  return `/data-services/catalog/${catalogId}`
}

export const getDataServicesByCatalogId = async (catalogId: string, options?: RequestInit): Promise<getDataServicesByCatalogIdResponse> => {
  
  return customInstance<getDataServicesByCatalogIdResponse>(getGetDataServicesByCatalogIdUrl(catalogId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetDataServicesByCatalogIdInfiniteQueryKey = (catalogId: string,) => {
    return [
    'infinite', `/data-services/catalog/${catalogId}`
    ] as const;
    }

export const getGetDataServicesByCatalogIdQueryKey = (catalogId: string,) => {
    return [
    `/data-services/catalog/${catalogId}`
    ] as const;
    }

    
export const getGetDataServicesByCatalogIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>, TError = ErrorType<ErrorInfo>>(catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataServicesByCatalogIdInfiniteQueryKey(catalogId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataServicesByCatalogId>>> = ({ signal }) => getDataServicesByCatalogId(catalogId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(catalogId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataServicesByCatalogIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>
export type GetDataServicesByCatalogIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetDataServicesByCatalogIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>,
          TError,
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServicesByCatalogIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>,
          TError,
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServicesByCatalogIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List data services by catalog
 */

export function useGetDataServicesByCatalogIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDataServicesByCatalogIdInfiniteQueryOptions(catalogId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetDataServicesByCatalogIdQueryOptions = <TData = Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError = ErrorType<ErrorInfo>>(catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataServicesByCatalogIdQueryKey(catalogId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataServicesByCatalogId>>> = ({ signal }) => getDataServicesByCatalogId(catalogId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(catalogId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataServicesByCatalogIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDataServicesByCatalogId>>>
export type GetDataServicesByCatalogIdQueryError = ErrorType<ErrorInfo>


export function useGetDataServicesByCatalogId<TData = Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>,
          TError,
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServicesByCatalogId<TData = Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>,
          TError,
          Awaited<ReturnType<typeof getDataServicesByCatalogId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServicesByCatalogId<TData = Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List data services by catalog
 */

export function useGetDataServicesByCatalogId<TData = Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServicesByCatalogId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDataServicesByCatalogIdQueryOptions(catalogId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get data service by ID
 */
export type getDataServiceByIdResponse200 = {
  data: DataServiceDto
  status: 200
}

export type getDataServiceByIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getDataServiceByIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getDataServiceByIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getDataServiceByIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getDataServiceByIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getDataServiceByIdResponseSuccess = (getDataServiceByIdResponse200) & {
  headers: Headers;
};
export type getDataServiceByIdResponseError = (getDataServiceByIdResponse400 | getDataServiceByIdResponse401 | getDataServiceByIdResponse403 | getDataServiceByIdResponse404 | getDataServiceByIdResponse500) & {
  headers: Headers;
};

export type getDataServiceByIdResponse = (getDataServiceByIdResponseSuccess | getDataServiceByIdResponseError)

export const getGetDataServiceByIdUrl = (dataServiceId: string,) => {


  

  return `/data-services/${dataServiceId}`
}

export const getDataServiceById = async (dataServiceId: string, options?: RequestInit): Promise<getDataServiceByIdResponse> => {
  
  return customInstance<getDataServiceByIdResponse>(getGetDataServiceByIdUrl(dataServiceId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetDataServiceByIdInfiniteQueryKey = (dataServiceId: string,) => {
    return [
    'infinite', `/data-services/${dataServiceId}`
    ] as const;
    }

export const getGetDataServiceByIdQueryKey = (dataServiceId: string,) => {
    return [
    `/data-services/${dataServiceId}`
    ] as const;
    }

    
export const getGetDataServiceByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDataServiceById>>>, TError = ErrorType<ErrorInfo>>(dataServiceId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataServiceByIdInfiniteQueryKey(dataServiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataServiceById>>> = ({ signal }) => getDataServiceById(dataServiceId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dataServiceId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataServiceByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDataServiceById>>>
export type GetDataServiceByIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetDataServiceByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServiceById>>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServiceById>>,
          TError,
          Awaited<ReturnType<typeof getDataServiceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServiceByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServiceById>>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServiceById>>,
          TError,
          Awaited<ReturnType<typeof getDataServiceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServiceByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServiceById>>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get data service by ID
 */

export function useGetDataServiceByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataServiceById>>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDataServiceByIdInfiniteQueryOptions(dataServiceId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetDataServiceByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDataServiceById>>, TError = ErrorType<ErrorInfo>>(dataServiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataServiceByIdQueryKey(dataServiceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataServiceById>>> = ({ signal }) => getDataServiceById(dataServiceId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dataServiceId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataServiceByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDataServiceById>>>
export type GetDataServiceByIdQueryError = ErrorType<ErrorInfo>


export function useGetDataServiceById<TData = Awaited<ReturnType<typeof getDataServiceById>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServiceById>>,
          TError,
          Awaited<ReturnType<typeof getDataServiceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServiceById<TData = Awaited<ReturnType<typeof getDataServiceById>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataServiceById>>,
          TError,
          Awaited<ReturnType<typeof getDataServiceById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataServiceById<TData = Awaited<ReturnType<typeof getDataServiceById>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get data service by ID
 */

export function useGetDataServiceById<TData = Awaited<ReturnType<typeof getDataServiceById>>, TError = ErrorType<ErrorInfo>>(
 dataServiceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataServiceById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDataServiceByIdQueryOptions(dataServiceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update a data service
 */
export type updateDataServiceResponse200 = {
  data: void
  status: 200
}

export type updateDataServiceResponse400 = {
  data: ErrorInfo
  status: 400
}

export type updateDataServiceResponse401 = {
  data: ErrorInfo
  status: 401
}

export type updateDataServiceResponse403 = {
  data: ErrorInfo
  status: 403
}

export type updateDataServiceResponse404 = {
  data: ErrorInfo
  status: 404
}

export type updateDataServiceResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type updateDataServiceResponseSuccess = (updateDataServiceResponse200) & {
  headers: Headers;
};
export type updateDataServiceResponseError = (updateDataServiceResponse400 | updateDataServiceResponse401 | updateDataServiceResponse403 | updateDataServiceResponse404 | updateDataServiceResponse500) & {
  headers: Headers;
};

export type updateDataServiceResponse = (updateDataServiceResponseSuccess | updateDataServiceResponseError)

export const getUpdateDataServiceUrl = (dataServiceId: string,) => {


  

  return `/data-services/${dataServiceId}`
}

export const updateDataService = async (dataServiceId: string,
    dataServiceDto: DataServiceDto, options?: RequestInit): Promise<updateDataServiceResponse> => {
  
  return customInstance<updateDataServiceResponse>(getUpdateDataServiceUrl(dataServiceId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      dataServiceDto,)
  }
);}




export const getUpdateDataServiceMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataService>>, TError,{dataServiceId: string;data: BodyType<DataServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDataService>>, TError,{dataServiceId: string;data: BodyType<DataServiceDto>}, TContext> => {

const mutationKey = ['updateDataService'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDataService>>, {dataServiceId: string;data: BodyType<DataServiceDto>}> = (props) => {
          const {dataServiceId,data} = props ?? {};

          return  updateDataService(dataServiceId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDataServiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateDataService>>>
    export type UpdateDataServiceMutationBody = BodyType<DataServiceDto>
    export type UpdateDataServiceMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Update a data service
 */
export const useUpdateDataService = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataService>>, TError,{dataServiceId: string;data: BodyType<DataServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDataService>>,
        TError,
        {dataServiceId: string;data: BodyType<DataServiceDto>},
        TContext
      > => {
      return useMutation(getUpdateDataServiceMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete a data service
 */
export type deleteDataServiceResponse204 = {
  data: void
  status: 204
}

export type deleteDataServiceResponse400 = {
  data: ErrorInfo
  status: 400
}

export type deleteDataServiceResponse401 = {
  data: ErrorInfo
  status: 401
}

export type deleteDataServiceResponse403 = {
  data: ErrorInfo
  status: 403
}

export type deleteDataServiceResponse404 = {
  data: ErrorInfo
  status: 404
}

export type deleteDataServiceResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type deleteDataServiceResponseSuccess = (deleteDataServiceResponse204) & {
  headers: Headers;
};
export type deleteDataServiceResponseError = (deleteDataServiceResponse400 | deleteDataServiceResponse401 | deleteDataServiceResponse403 | deleteDataServiceResponse404 | deleteDataServiceResponse500) & {
  headers: Headers;
};

export type deleteDataServiceResponse = (deleteDataServiceResponseSuccess | deleteDataServiceResponseError)

export const getDeleteDataServiceUrl = (dataServiceId: string,) => {


  

  return `/data-services/${dataServiceId}`
}

export const deleteDataService = async (dataServiceId: string, options?: RequestInit): Promise<deleteDataServiceResponse> => {
  
  return customInstance<deleteDataServiceResponse>(getDeleteDataServiceUrl(dataServiceId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteDataServiceMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataService>>, TError,{dataServiceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDataService>>, TError,{dataServiceId: string}, TContext> => {

const mutationKey = ['deleteDataService'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDataService>>, {dataServiceId: string}> = (props) => {
          const {dataServiceId} = props ?? {};

          return  deleteDataService(dataServiceId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDataServiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDataService>>>
    
    export type DeleteDataServiceMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Delete a data service
 */
export const useDeleteDataService = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataService>>, TError,{dataServiceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDataService>>,
        TError,
        {dataServiceId: string},
        TContext
      > => {
      return useMutation(getDeleteDataServiceMutationOptions(options), queryClient);
    }
    