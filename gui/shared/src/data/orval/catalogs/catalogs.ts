/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Rainbow Frontend Gateway API
 * OpenAPI specification for the Rainbow Frontend Gateway.
The gateway proxies requests from the GUI to backend microservices.
All paths are prefixed with `/api` and routed by service prefix to the
corresponding microservice (catalog-agent, negotiation-agent, transfer-agent, auth-agent).

 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Catalog,
  CatalogDto,
  ErrorInfo,
  GetCatalogsParams,
  NewCatalogDto
} from '.././model';

import { customInstance } from '../../orval-mutator';
import type { ErrorType , BodyType } from '../../orval-mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List catalogs
 */
export type getCatalogsResponse200 = {
  data: CatalogDto[]
  status: 200
}

export type getCatalogsResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getCatalogsResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getCatalogsResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getCatalogsResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getCatalogsResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getCatalogsResponseSuccess = (getCatalogsResponse200) & {
  headers: Headers;
};
export type getCatalogsResponseError = (getCatalogsResponse400 | getCatalogsResponse401 | getCatalogsResponse403 | getCatalogsResponse404 | getCatalogsResponse500) & {
  headers: Headers;
};

export type getCatalogsResponse = (getCatalogsResponseSuccess | getCatalogsResponseError)

export const getGetCatalogsUrl = (params?: GetCatalogsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/catalogs?${stringifiedParams}` : `/catalogs`
}

export const getCatalogs = async (params?: GetCatalogsParams, options?: RequestInit): Promise<getCatalogsResponse> => {
  
  return customInstance<getCatalogsResponse>(getGetCatalogsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCatalogsInfiniteQueryKey = (params?: GetCatalogsParams,) => {
    return [
    'infinite', `/catalogs`, ...(params ? [params] : [])
    ] as const;
    }

export const getGetCatalogsQueryKey = (params?: GetCatalogsParams,) => {
    return [
    `/catalogs`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetCatalogsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCatalogs>>>, TError = ErrorType<ErrorInfo>>(params?: GetCatalogsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCatalogsInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCatalogs>>> = ({ signal }) => getCatalogs(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCatalogsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCatalogs>>>
export type GetCatalogsInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogs>>>, TError = ErrorType<ErrorInfo>>(
 params: undefined |  GetCatalogsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogs>>>, TError = ErrorType<ErrorInfo>>(
 params?: GetCatalogsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogs>>>, TError = ErrorType<ErrorInfo>>(
 params?: GetCatalogsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List catalogs
 */

export function useGetCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogs>>>, TError = ErrorType<ErrorInfo>>(
 params?: GetCatalogsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCatalogsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetCatalogsQueryOptions = <TData = Awaited<ReturnType<typeof getCatalogs>>, TError = ErrorType<ErrorInfo>>(params?: GetCatalogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCatalogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCatalogs>>> = ({ signal }) => getCatalogs(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCatalogsQueryResult = NonNullable<Awaited<ReturnType<typeof getCatalogs>>>
export type GetCatalogsQueryError = ErrorType<ErrorInfo>


export function useGetCatalogs<TData = Awaited<ReturnType<typeof getCatalogs>>, TError = ErrorType<ErrorInfo>>(
 params: undefined |  GetCatalogsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogs<TData = Awaited<ReturnType<typeof getCatalogs>>, TError = ErrorType<ErrorInfo>>(
 params?: GetCatalogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogs<TData = Awaited<ReturnType<typeof getCatalogs>>, TError = ErrorType<ErrorInfo>>(
 params?: GetCatalogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List catalogs
 */

export function useGetCatalogs<TData = Awaited<ReturnType<typeof getCatalogs>>, TError = ErrorType<ErrorInfo>>(
 params?: GetCatalogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCatalogsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Create a catalog
 */
export type createCatalogResponse201 = {
  data: CatalogDto
  status: 201
}

export type createCatalogResponse400 = {
  data: ErrorInfo
  status: 400
}

export type createCatalogResponse401 = {
  data: ErrorInfo
  status: 401
}

export type createCatalogResponse403 = {
  data: ErrorInfo
  status: 403
}

export type createCatalogResponse404 = {
  data: ErrorInfo
  status: 404
}

export type createCatalogResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type createCatalogResponseSuccess = (createCatalogResponse201) & {
  headers: Headers;
};
export type createCatalogResponseError = (createCatalogResponse400 | createCatalogResponse401 | createCatalogResponse403 | createCatalogResponse404 | createCatalogResponse500) & {
  headers: Headers;
};

export type createCatalogResponse = (createCatalogResponseSuccess | createCatalogResponseError)

export const getCreateCatalogUrl = () => {


  

  return `/catalogs`
}

export const createCatalog = async (newCatalogDto: NewCatalogDto, options?: RequestInit): Promise<createCatalogResponse> => {
  
  return customInstance<createCatalogResponse>(getCreateCatalogUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      newCatalogDto,)
  }
);}




export const getCreateCatalogMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCatalog>>, TError,{data: BodyType<NewCatalogDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCatalog>>, TError,{data: BodyType<NewCatalogDto>}, TContext> => {

const mutationKey = ['createCatalog'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCatalog>>, {data: BodyType<NewCatalogDto>}> = (props) => {
          const {data} = props ?? {};

          return  createCatalog(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCatalogMutationResult = NonNullable<Awaited<ReturnType<typeof createCatalog>>>
    export type CreateCatalogMutationBody = BodyType<NewCatalogDto>
    export type CreateCatalogMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Create a catalog
 */
export const useCreateCatalog = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCatalog>>, TError,{data: BodyType<NewCatalogDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCatalog>>,
        TError,
        {data: BodyType<NewCatalogDto>},
        TContext
      > => {
      return useMutation(getCreateCatalogMutationOptions(options), queryClient);
    }
    /**
 * @summary Get the main catalog
 */
export type getMainCatalogsResponse200 = {
  data: CatalogDto
  status: 200
}

export type getMainCatalogsResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getMainCatalogsResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getMainCatalogsResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getMainCatalogsResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getMainCatalogsResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getMainCatalogsResponseSuccess = (getMainCatalogsResponse200) & {
  headers: Headers;
};
export type getMainCatalogsResponseError = (getMainCatalogsResponse400 | getMainCatalogsResponse401 | getMainCatalogsResponse403 | getMainCatalogsResponse404 | getMainCatalogsResponse500) & {
  headers: Headers;
};

export type getMainCatalogsResponse = (getMainCatalogsResponseSuccess | getMainCatalogsResponseError)

export const getGetMainCatalogsUrl = () => {


  

  return `/catalogs/main`
}

export const getMainCatalogs = async ( options?: RequestInit): Promise<getMainCatalogsResponse> => {
  
  return customInstance<getMainCatalogsResponse>(getGetMainCatalogsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetMainCatalogsInfiniteQueryKey = () => {
    return [
    'infinite', `/catalogs/main`
    ] as const;
    }

export const getGetMainCatalogsQueryKey = () => {
    return [
    `/catalogs/main`
    ] as const;
    }

    
export const getGetMainCatalogsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMainCatalogs>>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMainCatalogsInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMainCatalogs>>> = ({ signal }) => getMainCatalogs({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMainCatalogsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMainCatalogs>>>
export type GetMainCatalogsInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetMainCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMainCatalogs>>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMainCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getMainCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMainCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMainCatalogs>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMainCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getMainCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMainCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMainCatalogs>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the main catalog
 */

export function useGetMainCatalogsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMainCatalogs>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMainCatalogsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetMainCatalogsQueryOptions = <TData = Awaited<ReturnType<typeof getMainCatalogs>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMainCatalogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMainCatalogs>>> = ({ signal }) => getMainCatalogs({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMainCatalogsQueryResult = NonNullable<Awaited<ReturnType<typeof getMainCatalogs>>>
export type GetMainCatalogsQueryError = ErrorType<ErrorInfo>


export function useGetMainCatalogs<TData = Awaited<ReturnType<typeof getMainCatalogs>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMainCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getMainCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMainCatalogs<TData = Awaited<ReturnType<typeof getMainCatalogs>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMainCatalogs>>,
          TError,
          Awaited<ReturnType<typeof getMainCatalogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMainCatalogs<TData = Awaited<ReturnType<typeof getMainCatalogs>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the main catalog
 */

export function useGetMainCatalogs<TData = Awaited<ReturnType<typeof getMainCatalogs>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMainCatalogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMainCatalogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get catalog by ID
 */
export type getCatalogByIdResponse200 = {
  data: CatalogDto
  status: 200
}

export type getCatalogByIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getCatalogByIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getCatalogByIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getCatalogByIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getCatalogByIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getCatalogByIdResponseSuccess = (getCatalogByIdResponse200) & {
  headers: Headers;
};
export type getCatalogByIdResponseError = (getCatalogByIdResponse400 | getCatalogByIdResponse401 | getCatalogByIdResponse403 | getCatalogByIdResponse404 | getCatalogByIdResponse500) & {
  headers: Headers;
};

export type getCatalogByIdResponse = (getCatalogByIdResponseSuccess | getCatalogByIdResponseError)

export const getGetCatalogByIdUrl = (catalogId: string,) => {


  

  return `/catalogs/${catalogId}`
}

export const getCatalogById = async (catalogId: string, options?: RequestInit): Promise<getCatalogByIdResponse> => {
  
  return customInstance<getCatalogByIdResponse>(getGetCatalogByIdUrl(catalogId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCatalogByIdInfiniteQueryKey = (catalogId: string,) => {
    return [
    'infinite', `/catalogs/${catalogId}`
    ] as const;
    }

export const getGetCatalogByIdQueryKey = (catalogId: string,) => {
    return [
    `/catalogs/${catalogId}`
    ] as const;
    }

    
export const getGetCatalogByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCatalogById>>>, TError = ErrorType<ErrorInfo>>(catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCatalogByIdInfiniteQueryKey(catalogId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCatalogById>>> = ({ signal }) => getCatalogById(catalogId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(catalogId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCatalogByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCatalogById>>>
export type GetCatalogByIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetCatalogByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogById>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogById>>,
          TError,
          Awaited<ReturnType<typeof getCatalogById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogById>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogById>>,
          TError,
          Awaited<ReturnType<typeof getCatalogById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogById>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get catalog by ID
 */

export function useGetCatalogByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCatalogById>>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCatalogByIdInfiniteQueryOptions(catalogId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetCatalogByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCatalogById>>, TError = ErrorType<ErrorInfo>>(catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCatalogByIdQueryKey(catalogId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCatalogById>>> = ({ signal }) => getCatalogById(catalogId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(catalogId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCatalogByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCatalogById>>>
export type GetCatalogByIdQueryError = ErrorType<ErrorInfo>


export function useGetCatalogById<TData = Awaited<ReturnType<typeof getCatalogById>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogById>>,
          TError,
          Awaited<ReturnType<typeof getCatalogById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogById<TData = Awaited<ReturnType<typeof getCatalogById>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogById>>,
          TError,
          Awaited<ReturnType<typeof getCatalogById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCatalogById<TData = Awaited<ReturnType<typeof getCatalogById>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get catalog by ID
 */

export function useGetCatalogById<TData = Awaited<ReturnType<typeof getCatalogById>>, TError = ErrorType<ErrorInfo>>(
 catalogId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCatalogByIdQueryOptions(catalogId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update a catalog
 */
export type updateCatalogResponse200 = {
  data: CatalogDto
  status: 200
}

export type updateCatalogResponse400 = {
  data: ErrorInfo
  status: 400
}

export type updateCatalogResponse401 = {
  data: ErrorInfo
  status: 401
}

export type updateCatalogResponse403 = {
  data: ErrorInfo
  status: 403
}

export type updateCatalogResponse404 = {
  data: ErrorInfo
  status: 404
}

export type updateCatalogResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type updateCatalogResponseSuccess = (updateCatalogResponse200) & {
  headers: Headers;
};
export type updateCatalogResponseError = (updateCatalogResponse400 | updateCatalogResponse401 | updateCatalogResponse403 | updateCatalogResponse404 | updateCatalogResponse500) & {
  headers: Headers;
};

export type updateCatalogResponse = (updateCatalogResponseSuccess | updateCatalogResponseError)

export const getUpdateCatalogUrl = (catalogId: string,) => {


  

  return `/catalogs/${catalogId}`
}

export const updateCatalog = async (catalogId: string,
    catalogDto: CatalogDto, options?: RequestInit): Promise<updateCatalogResponse> => {
  
  return customInstance<updateCatalogResponse>(getUpdateCatalogUrl(catalogId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      catalogDto,)
  }
);}




export const getUpdateCatalogMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCatalog>>, TError,{catalogId: string;data: BodyType<CatalogDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCatalog>>, TError,{catalogId: string;data: BodyType<CatalogDto>}, TContext> => {

const mutationKey = ['updateCatalog'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCatalog>>, {catalogId: string;data: BodyType<CatalogDto>}> = (props) => {
          const {catalogId,data} = props ?? {};

          return  updateCatalog(catalogId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCatalogMutationResult = NonNullable<Awaited<ReturnType<typeof updateCatalog>>>
    export type UpdateCatalogMutationBody = BodyType<CatalogDto>
    export type UpdateCatalogMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Update a catalog
 */
export const useUpdateCatalog = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCatalog>>, TError,{catalogId: string;data: BodyType<CatalogDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCatalog>>,
        TError,
        {catalogId: string;data: BodyType<CatalogDto>},
        TContext
      > => {
      return useMutation(getUpdateCatalogMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete a catalog
 */
export type deleteCatalogResponse204 = {
  data: void
  status: 204
}

export type deleteCatalogResponse400 = {
  data: ErrorInfo
  status: 400
}

export type deleteCatalogResponse401 = {
  data: ErrorInfo
  status: 401
}

export type deleteCatalogResponse403 = {
  data: ErrorInfo
  status: 403
}

export type deleteCatalogResponse404 = {
  data: ErrorInfo
  status: 404
}

export type deleteCatalogResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type deleteCatalogResponseSuccess = (deleteCatalogResponse204) & {
  headers: Headers;
};
export type deleteCatalogResponseError = (deleteCatalogResponse400 | deleteCatalogResponse401 | deleteCatalogResponse403 | deleteCatalogResponse404 | deleteCatalogResponse500) & {
  headers: Headers;
};

export type deleteCatalogResponse = (deleteCatalogResponseSuccess | deleteCatalogResponseError)

export const getDeleteCatalogUrl = (catalogId: string,) => {


  

  return `/catalogs/${catalogId}`
}

export const deleteCatalog = async (catalogId: string, options?: RequestInit): Promise<deleteCatalogResponse> => {
  
  return customInstance<deleteCatalogResponse>(getDeleteCatalogUrl(catalogId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteCatalogMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCatalog>>, TError,{catalogId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCatalog>>, TError,{catalogId: string}, TContext> => {

const mutationKey = ['deleteCatalog'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCatalog>>, {catalogId: string}> = (props) => {
          const {catalogId} = props ?? {};

          return  deleteCatalog(catalogId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCatalogMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCatalog>>>
    
    export type DeleteCatalogMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Delete a catalog
 */
export const useDeleteCatalog = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCatalog>>, TError,{catalogId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCatalog>>,
        TError,
        {catalogId: string},
        TContext
      > => {
      return useMutation(getDeleteCatalogMutationOptions(options), queryClient);
    }
    /**
 * @summary Get remote peer catalog
 */
export type getPeerCatalogResponse200 = {
  data: Catalog
  status: 200
}

export type getPeerCatalogResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getPeerCatalogResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getPeerCatalogResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getPeerCatalogResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getPeerCatalogResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getPeerCatalogResponseSuccess = (getPeerCatalogResponse200) & {
  headers: Headers;
};
export type getPeerCatalogResponseError = (getPeerCatalogResponse400 | getPeerCatalogResponse401 | getPeerCatalogResponse403 | getPeerCatalogResponse404 | getPeerCatalogResponse500) & {
  headers: Headers;
};

export type getPeerCatalogResponse = (getPeerCatalogResponseSuccess | getPeerCatalogResponseError)

export const getGetPeerCatalogUrl = (peerId: string,) => {


  

  return `/peer-catalogs/${peerId}`
}

export const getPeerCatalog = async (peerId: string, options?: RequestInit): Promise<getPeerCatalogResponse> => {
  
  return customInstance<getPeerCatalogResponse>(getGetPeerCatalogUrl(peerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetPeerCatalogInfiniteQueryKey = (peerId: string,) => {
    return [
    'infinite', `/peer-catalogs/${peerId}`
    ] as const;
    }

export const getGetPeerCatalogQueryKey = (peerId: string,) => {
    return [
    `/peer-catalogs/${peerId}`
    ] as const;
    }

    
export const getGetPeerCatalogInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getPeerCatalog>>>, TError = ErrorType<ErrorInfo>>(peerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPeerCatalogInfiniteQueryKey(peerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeerCatalog>>> = ({ signal }) => getPeerCatalog(peerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(peerId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPeerCatalogInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPeerCatalog>>>
export type GetPeerCatalogInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetPeerCatalogInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPeerCatalog>>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeerCatalog>>,
          TError,
          Awaited<ReturnType<typeof getPeerCatalog>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPeerCatalogInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPeerCatalog>>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeerCatalog>>,
          TError,
          Awaited<ReturnType<typeof getPeerCatalog>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPeerCatalogInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPeerCatalog>>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get remote peer catalog
 */

export function useGetPeerCatalogInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getPeerCatalog>>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPeerCatalogInfiniteQueryOptions(peerId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetPeerCatalogQueryOptions = <TData = Awaited<ReturnType<typeof getPeerCatalog>>, TError = ErrorType<ErrorInfo>>(peerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPeerCatalogQueryKey(peerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPeerCatalog>>> = ({ signal }) => getPeerCatalog(peerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(peerId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPeerCatalogQueryResult = NonNullable<Awaited<ReturnType<typeof getPeerCatalog>>>
export type GetPeerCatalogQueryError = ErrorType<ErrorInfo>


export function useGetPeerCatalog<TData = Awaited<ReturnType<typeof getPeerCatalog>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeerCatalog>>,
          TError,
          Awaited<ReturnType<typeof getPeerCatalog>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPeerCatalog<TData = Awaited<ReturnType<typeof getPeerCatalog>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPeerCatalog>>,
          TError,
          Awaited<ReturnType<typeof getPeerCatalog>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPeerCatalog<TData = Awaited<ReturnType<typeof getPeerCatalog>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get remote peer catalog
 */

export function useGetPeerCatalog<TData = Awaited<ReturnType<typeof getPeerCatalog>>, TError = ErrorType<ErrorInfo>>(
 peerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPeerCatalog>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPeerCatalogQueryOptions(peerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




