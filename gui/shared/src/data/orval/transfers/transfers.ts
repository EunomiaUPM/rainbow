/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Rainbow Frontend Gateway API
 * OpenAPI specification for the Rainbow Frontend Gateway.
The gateway proxies requests from the GUI to backend microservices.
All paths are prefixed with `/api` and routed by service prefix to the
corresponding microservice (catalog-agent, negotiation-agent, transfer-agent, auth-agent).

 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ErrorInfo,
  GetDataplaneSession200,
  TransferMessageDto,
  TransferProcessDto
} from '.././model';

import { customInstance } from '../../orval-mutator';
import type { ErrorType , BodyType } from '../../orval-mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List all transfer processes
 */
export type getTransferProcessesResponse200 = {
  data: TransferProcessDto[]
  status: 200
}

export type getTransferProcessesResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getTransferProcessesResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getTransferProcessesResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getTransferProcessesResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getTransferProcessesResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getTransferProcessesResponseSuccess = (getTransferProcessesResponse200) & {
  headers: Headers;
};
export type getTransferProcessesResponseError = (getTransferProcessesResponse400 | getTransferProcessesResponse401 | getTransferProcessesResponse403 | getTransferProcessesResponse404 | getTransferProcessesResponse500) & {
  headers: Headers;
};

export type getTransferProcessesResponse = (getTransferProcessesResponseSuccess | getTransferProcessesResponseError)

export const getGetTransferProcessesUrl = () => {


  

  return `/transfers/transfer-processes`
}

export const getTransferProcesses = async ( options?: RequestInit): Promise<getTransferProcessesResponse> => {
  
  return customInstance<getTransferProcessesResponse>(getGetTransferProcessesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTransferProcessesInfiniteQueryKey = () => {
    return [
    'infinite', `/transfers/transfer-processes`
    ] as const;
    }

export const getGetTransferProcessesQueryKey = () => {
    return [
    `/transfers/transfer-processes`
    ] as const;
    }

    
export const getGetTransferProcessesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcesses>>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferProcessesInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferProcesses>>> = ({ signal }) => getTransferProcesses({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferProcessesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferProcesses>>>
export type GetTransferProcessesInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetTransferProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcesses>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcesses>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all transfer processes
 */

export function useGetTransferProcessesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcesses>>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferProcessesInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetTransferProcessesQueryOptions = <TData = Awaited<ReturnType<typeof getTransferProcesses>>, TError = ErrorType<ErrorInfo>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferProcessesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferProcesses>>> = ({ signal }) => getTransferProcesses({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferProcessesQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferProcesses>>>
export type GetTransferProcessesQueryError = ErrorType<ErrorInfo>


export function useGetTransferProcesses<TData = Awaited<ReturnType<typeof getTransferProcesses>>, TError = ErrorType<ErrorInfo>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcesses>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcesses<TData = Awaited<ReturnType<typeof getTransferProcesses>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcesses>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcesses>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcesses<TData = Awaited<ReturnType<typeof getTransferProcesses>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all transfer processes
 */

export function useGetTransferProcesses<TData = Awaited<ReturnType<typeof getTransferProcesses>>, TError = ErrorType<ErrorInfo>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcesses>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferProcessesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Create a transfer process
 */
export type createTransferProcessResponse201 = {
  data: void
  status: 201
}

export type createTransferProcessResponse400 = {
  data: ErrorInfo
  status: 400
}

export type createTransferProcessResponse401 = {
  data: ErrorInfo
  status: 401
}

export type createTransferProcessResponse403 = {
  data: ErrorInfo
  status: 403
}

export type createTransferProcessResponse404 = {
  data: ErrorInfo
  status: 404
}

export type createTransferProcessResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type createTransferProcessResponseSuccess = (createTransferProcessResponse201) & {
  headers: Headers;
};
export type createTransferProcessResponseError = (createTransferProcessResponse400 | createTransferProcessResponse401 | createTransferProcessResponse403 | createTransferProcessResponse404 | createTransferProcessResponse500) & {
  headers: Headers;
};

export type createTransferProcessResponse = (createTransferProcessResponseSuccess | createTransferProcessResponseError)

export const getCreateTransferProcessUrl = () => {


  

  return `/transfers/transfer-processes`
}

export const createTransferProcess = async (transferProcessDto: TransferProcessDto, options?: RequestInit): Promise<createTransferProcessResponse> => {
  
  return customInstance<createTransferProcessResponse>(getCreateTransferProcessUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      transferProcessDto,)
  }
);}




export const getCreateTransferProcessMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransferProcess>>, TError,{data: BodyType<TransferProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTransferProcess>>, TError,{data: BodyType<TransferProcessDto>}, TContext> => {

const mutationKey = ['createTransferProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTransferProcess>>, {data: BodyType<TransferProcessDto>}> = (props) => {
          const {data} = props ?? {};

          return  createTransferProcess(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTransferProcessMutationResult = NonNullable<Awaited<ReturnType<typeof createTransferProcess>>>
    export type CreateTransferProcessMutationBody = BodyType<TransferProcessDto>
    export type CreateTransferProcessMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Create a transfer process
 */
export const useCreateTransferProcess = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTransferProcess>>, TError,{data: BodyType<TransferProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTransferProcess>>,
        TError,
        {data: BodyType<TransferProcessDto>},
        TContext
      > => {
      return useMutation(getCreateTransferProcessMutationOptions(options), queryClient);
    }
    /**
 * @summary Get transfer process by ID
 */
export type getTransferProcessByIdResponse200 = {
  data: TransferProcessDto
  status: 200
}

export type getTransferProcessByIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getTransferProcessByIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getTransferProcessByIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getTransferProcessByIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getTransferProcessByIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getTransferProcessByIdResponseSuccess = (getTransferProcessByIdResponse200) & {
  headers: Headers;
};
export type getTransferProcessByIdResponseError = (getTransferProcessByIdResponse400 | getTransferProcessByIdResponse401 | getTransferProcessByIdResponse403 | getTransferProcessByIdResponse404 | getTransferProcessByIdResponse500) & {
  headers: Headers;
};

export type getTransferProcessByIdResponse = (getTransferProcessByIdResponseSuccess | getTransferProcessByIdResponseError)

export const getGetTransferProcessByIdUrl = (processId: string,) => {


  

  return `/transfers/transfer-processes/${processId}`
}

export const getTransferProcessById = async (processId: string, options?: RequestInit): Promise<getTransferProcessByIdResponse> => {
  
  return customInstance<getTransferProcessByIdResponse>(getGetTransferProcessByIdUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTransferProcessByIdInfiniteQueryKey = (processId: string,) => {
    return [
    'infinite', `/transfers/transfer-processes/${processId}`
    ] as const;
    }

export const getGetTransferProcessByIdQueryKey = (processId: string,) => {
    return [
    `/transfers/transfer-processes/${processId}`
    ] as const;
    }

    
export const getGetTransferProcessByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcessById>>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferProcessByIdInfiniteQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferProcessById>>> = ({ signal }) => getTransferProcessById(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferProcessByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferProcessById>>>
export type GetTransferProcessByIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetTransferProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcessById>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcessById>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get transfer process by ID
 */

export function useGetTransferProcessByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferProcessById>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferProcessByIdInfiniteQueryOptions(processId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetTransferProcessByIdQueryOptions = <TData = Awaited<ReturnType<typeof getTransferProcessById>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferProcessByIdQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferProcessById>>> = ({ signal }) => getTransferProcessById(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferProcessByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferProcessById>>>
export type GetTransferProcessByIdQueryError = ErrorType<ErrorInfo>


export function useGetTransferProcessById<TData = Awaited<ReturnType<typeof getTransferProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcessById>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcessById<TData = Awaited<ReturnType<typeof getTransferProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferProcessById>>,
          TError,
          Awaited<ReturnType<typeof getTransferProcessById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferProcessById<TData = Awaited<ReturnType<typeof getTransferProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get transfer process by ID
 */

export function useGetTransferProcessById<TData = Awaited<ReturnType<typeof getTransferProcessById>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferProcessById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferProcessByIdQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update a transfer process
 */
export type updateTransferProcessResponse200 = {
  data: void
  status: 200
}

export type updateTransferProcessResponse400 = {
  data: ErrorInfo
  status: 400
}

export type updateTransferProcessResponse401 = {
  data: ErrorInfo
  status: 401
}

export type updateTransferProcessResponse403 = {
  data: ErrorInfo
  status: 403
}

export type updateTransferProcessResponse404 = {
  data: ErrorInfo
  status: 404
}

export type updateTransferProcessResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type updateTransferProcessResponseSuccess = (updateTransferProcessResponse200) & {
  headers: Headers;
};
export type updateTransferProcessResponseError = (updateTransferProcessResponse400 | updateTransferProcessResponse401 | updateTransferProcessResponse403 | updateTransferProcessResponse404 | updateTransferProcessResponse500) & {
  headers: Headers;
};

export type updateTransferProcessResponse = (updateTransferProcessResponseSuccess | updateTransferProcessResponseError)

export const getUpdateTransferProcessUrl = (processId: string,) => {


  

  return `/transfers/transfer-processes/${processId}`
}

export const updateTransferProcess = async (processId: string,
    transferProcessDto: TransferProcessDto, options?: RequestInit): Promise<updateTransferProcessResponse> => {
  
  return customInstance<updateTransferProcessResponse>(getUpdateTransferProcessUrl(processId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      transferProcessDto,)
  }
);}




export const getUpdateTransferProcessMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTransferProcess>>, TError,{processId: string;data: BodyType<TransferProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTransferProcess>>, TError,{processId: string;data: BodyType<TransferProcessDto>}, TContext> => {

const mutationKey = ['updateTransferProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTransferProcess>>, {processId: string;data: BodyType<TransferProcessDto>}> = (props) => {
          const {processId,data} = props ?? {};

          return  updateTransferProcess(processId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTransferProcessMutationResult = NonNullable<Awaited<ReturnType<typeof updateTransferProcess>>>
    export type UpdateTransferProcessMutationBody = BodyType<TransferProcessDto>
    export type UpdateTransferProcessMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Update a transfer process
 */
export const useUpdateTransferProcess = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTransferProcess>>, TError,{processId: string;data: BodyType<TransferProcessDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTransferProcess>>,
        TError,
        {processId: string;data: BodyType<TransferProcessDto>},
        TContext
      > => {
      return useMutation(getUpdateTransferProcessMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete a transfer process
 */
export type deleteTransferProcessResponse204 = {
  data: void
  status: 204
}

export type deleteTransferProcessResponse400 = {
  data: ErrorInfo
  status: 400
}

export type deleteTransferProcessResponse401 = {
  data: ErrorInfo
  status: 401
}

export type deleteTransferProcessResponse403 = {
  data: ErrorInfo
  status: 403
}

export type deleteTransferProcessResponse404 = {
  data: ErrorInfo
  status: 404
}

export type deleteTransferProcessResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type deleteTransferProcessResponseSuccess = (deleteTransferProcessResponse204) & {
  headers: Headers;
};
export type deleteTransferProcessResponseError = (deleteTransferProcessResponse400 | deleteTransferProcessResponse401 | deleteTransferProcessResponse403 | deleteTransferProcessResponse404 | deleteTransferProcessResponse500) & {
  headers: Headers;
};

export type deleteTransferProcessResponse = (deleteTransferProcessResponseSuccess | deleteTransferProcessResponseError)

export const getDeleteTransferProcessUrl = (processId: string,) => {


  

  return `/transfers/transfer-processes/${processId}`
}

export const deleteTransferProcess = async (processId: string, options?: RequestInit): Promise<deleteTransferProcessResponse> => {
  
  return customInstance<deleteTransferProcessResponse>(getDeleteTransferProcessUrl(processId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTransferProcessMutationOptions = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTransferProcess>>, TError,{processId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTransferProcess>>, TError,{processId: string}, TContext> => {

const mutationKey = ['deleteTransferProcess'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTransferProcess>>, {processId: string}> = (props) => {
          const {processId} = props ?? {};

          return  deleteTransferProcess(processId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTransferProcessMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTransferProcess>>>
    
    export type DeleteTransferProcessMutationError = ErrorType<ErrorInfo>

    /**
 * @summary Delete a transfer process
 */
export const useDeleteTransferProcess = <TError = ErrorType<ErrorInfo>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTransferProcess>>, TError,{processId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTransferProcess>>,
        TError,
        {processId: string},
        TContext
      > => {
      return useMutation(getDeleteTransferProcessMutationOptions(options), queryClient);
    }
    /**
 * @summary List messages for a transfer process
 */
export type getTransferMessagesByProcessIdResponse200 = {
  data: TransferMessageDto[]
  status: 200
}

export type getTransferMessagesByProcessIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getTransferMessagesByProcessIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getTransferMessagesByProcessIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getTransferMessagesByProcessIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getTransferMessagesByProcessIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getTransferMessagesByProcessIdResponseSuccess = (getTransferMessagesByProcessIdResponse200) & {
  headers: Headers;
};
export type getTransferMessagesByProcessIdResponseError = (getTransferMessagesByProcessIdResponse400 | getTransferMessagesByProcessIdResponse401 | getTransferMessagesByProcessIdResponse403 | getTransferMessagesByProcessIdResponse404 | getTransferMessagesByProcessIdResponse500) & {
  headers: Headers;
};

export type getTransferMessagesByProcessIdResponse = (getTransferMessagesByProcessIdResponseSuccess | getTransferMessagesByProcessIdResponseError)

export const getGetTransferMessagesByProcessIdUrl = (processId: string,) => {


  

  return `/transfers/transfer-messages/process/${processId}`
}

export const getTransferMessagesByProcessId = async (processId: string, options?: RequestInit): Promise<getTransferMessagesByProcessIdResponse> => {
  
  return customInstance<getTransferMessagesByProcessIdResponse>(getGetTransferMessagesByProcessIdUrl(processId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTransferMessagesByProcessIdInfiniteQueryKey = (processId: string,) => {
    return [
    'infinite', `/transfers/transfer-messages/process/${processId}`
    ] as const;
    }

export const getGetTransferMessagesByProcessIdQueryKey = (processId: string,) => {
    return [
    `/transfers/transfer-messages/process/${processId}`
    ] as const;
    }

    
export const getGetTransferMessagesByProcessIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferMessagesByProcessIdInfiniteQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>> = ({ signal }) => getTransferMessagesByProcessId(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferMessagesByProcessIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>
export type GetTransferMessagesByProcessIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetTransferMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List messages for a transfer process
 */

export function useGetTransferMessagesByProcessIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferMessagesByProcessIdInfiniteQueryOptions(processId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetTransferMessagesByProcessIdQueryOptions = <TData = Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferMessagesByProcessIdQueryKey(processId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>> = ({ signal }) => getTransferMessagesByProcessId(processId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(processId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferMessagesByProcessIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>>
export type GetTransferMessagesByProcessIdQueryError = ErrorType<ErrorInfo>


export function useGetTransferMessagesByProcessId<TData = Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessagesByProcessId<TData = Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessagesByProcessId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessagesByProcessId<TData = Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List messages for a transfer process
 */

export function useGetTransferMessagesByProcessId<TData = Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError = ErrorType<ErrorInfo>>(
 processId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessagesByProcessId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferMessagesByProcessIdQueryOptions(processId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get a transfer message by ID
 */
export type getTransferMessageByIdResponse200 = {
  data: TransferMessageDto
  status: 200
}

export type getTransferMessageByIdResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getTransferMessageByIdResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getTransferMessageByIdResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getTransferMessageByIdResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getTransferMessageByIdResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getTransferMessageByIdResponseSuccess = (getTransferMessageByIdResponse200) & {
  headers: Headers;
};
export type getTransferMessageByIdResponseError = (getTransferMessageByIdResponse400 | getTransferMessageByIdResponse401 | getTransferMessageByIdResponse403 | getTransferMessageByIdResponse404 | getTransferMessageByIdResponse500) & {
  headers: Headers;
};

export type getTransferMessageByIdResponse = (getTransferMessageByIdResponseSuccess | getTransferMessageByIdResponseError)

export const getGetTransferMessageByIdUrl = (messageId: string,) => {


  

  return `/transfers/transfer-messages/${messageId}`
}

export const getTransferMessageById = async (messageId: string, options?: RequestInit): Promise<getTransferMessageByIdResponse> => {
  
  return customInstance<getTransferMessageByIdResponse>(getGetTransferMessageByIdUrl(messageId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTransferMessageByIdInfiniteQueryKey = (messageId: string,) => {
    return [
    'infinite', `/transfers/transfer-messages/${messageId}`
    ] as const;
    }

export const getGetTransferMessageByIdQueryKey = (messageId: string,) => {
    return [
    `/transfers/transfer-messages/${messageId}`
    ] as const;
    }

    
export const getGetTransferMessageByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessageById>>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferMessageByIdInfiniteQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferMessageById>>> = ({ signal }) => getTransferMessageById(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferMessageByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferMessageById>>>
export type GetTransferMessageByIdInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetTransferMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessageById>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessageById>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a transfer message by ID
 */

export function useGetTransferMessageByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTransferMessageById>>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferMessageByIdInfiniteQueryOptions(messageId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetTransferMessageByIdQueryOptions = <TData = Awaited<ReturnType<typeof getTransferMessageById>>, TError = ErrorType<ErrorInfo>>(messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransferMessageByIdQueryKey(messageId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransferMessageById>>> = ({ signal }) => getTransferMessageById(messageId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messageId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTransferMessageByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTransferMessageById>>>
export type GetTransferMessageByIdQueryError = ErrorType<ErrorInfo>


export function useGetTransferMessageById<TData = Awaited<ReturnType<typeof getTransferMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessageById>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessageById<TData = Awaited<ReturnType<typeof getTransferMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransferMessageById>>,
          TError,
          Awaited<ReturnType<typeof getTransferMessageById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTransferMessageById<TData = Awaited<ReturnType<typeof getTransferMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a transfer message by ID
 */

export function useGetTransferMessageById<TData = Awaited<ReturnType<typeof getTransferMessageById>>, TError = ErrorType<ErrorInfo>>(
 messageId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransferMessageById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTransferMessageByIdQueryOptions(messageId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get a dataplane session by ID
 */
export type getDataplaneSessionResponse200 = {
  data: GetDataplaneSession200
  status: 200
}

export type getDataplaneSessionResponse400 = {
  data: ErrorInfo
  status: 400
}

export type getDataplaneSessionResponse401 = {
  data: ErrorInfo
  status: 401
}

export type getDataplaneSessionResponse403 = {
  data: ErrorInfo
  status: 403
}

export type getDataplaneSessionResponse404 = {
  data: ErrorInfo
  status: 404
}

export type getDataplaneSessionResponse500 = {
  data: ErrorInfo
  status: 500
}
    
export type getDataplaneSessionResponseSuccess = (getDataplaneSessionResponse200) & {
  headers: Headers;
};
export type getDataplaneSessionResponseError = (getDataplaneSessionResponse400 | getDataplaneSessionResponse401 | getDataplaneSessionResponse403 | getDataplaneSessionResponse404 | getDataplaneSessionResponse500) & {
  headers: Headers;
};

export type getDataplaneSessionResponse = (getDataplaneSessionResponseSuccess | getDataplaneSessionResponseError)

export const getGetDataplaneSessionUrl = (sessionId: string,) => {


  

  return `/transfers/dataplane/${sessionId}`
}

export const getDataplaneSession = async (sessionId: string, options?: RequestInit): Promise<getDataplaneSessionResponse> => {
  
  return customInstance<getDataplaneSessionResponse>(getGetDataplaneSessionUrl(sessionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetDataplaneSessionInfiniteQueryKey = (sessionId: string,) => {
    return [
    'infinite', `/transfers/dataplane/${sessionId}`
    ] as const;
    }

export const getGetDataplaneSessionQueryKey = (sessionId: string,) => {
    return [
    `/transfers/dataplane/${sessionId}`
    ] as const;
    }

    
export const getGetDataplaneSessionInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDataplaneSession>>>, TError = ErrorType<ErrorInfo>>(sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataplaneSessionInfiniteQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataplaneSession>>> = ({ signal }) => getDataplaneSession(sessionId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataplaneSessionInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDataplaneSession>>>
export type GetDataplaneSessionInfiniteQueryError = ErrorType<ErrorInfo>


export function useGetDataplaneSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataplaneSession>>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataplaneSession>>,
          TError,
          Awaited<ReturnType<typeof getDataplaneSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataplaneSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataplaneSession>>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataplaneSession>>,
          TError,
          Awaited<ReturnType<typeof getDataplaneSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataplaneSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataplaneSession>>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a dataplane session by ID
 */

export function useGetDataplaneSessionInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDataplaneSession>>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDataplaneSessionInfiniteQueryOptions(sessionId,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




export const getGetDataplaneSessionQueryOptions = <TData = Awaited<ReturnType<typeof getDataplaneSession>>, TError = ErrorType<ErrorInfo>>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDataplaneSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDataplaneSession>>> = ({ signal }) => getDataplaneSession(sessionId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId),  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDataplaneSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getDataplaneSession>>>
export type GetDataplaneSessionQueryError = ErrorType<ErrorInfo>


export function useGetDataplaneSession<TData = Awaited<ReturnType<typeof getDataplaneSession>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataplaneSession>>,
          TError,
          Awaited<ReturnType<typeof getDataplaneSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataplaneSession<TData = Awaited<ReturnType<typeof getDataplaneSession>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDataplaneSession>>,
          TError,
          Awaited<ReturnType<typeof getDataplaneSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDataplaneSession<TData = Awaited<ReturnType<typeof getDataplaneSession>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get a dataplane session by ID
 */

export function useGetDataplaneSession<TData = Awaited<ReturnType<typeof getDataplaneSession>>, TError = ErrorType<ErrorInfo>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDataplaneSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDataplaneSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  return { ...query, queryKey: queryOptions.queryKey };
}




