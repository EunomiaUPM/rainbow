---
title: "ADR-005-3: Instantiation Orchestration & Secret Vaulting"
description: "ADR-005-3: Instantiation Orchestration & Secret Vaulting"
---

**Date:** January 30, 2026
**Status:** Accepted
**Context:** Provisioning Pipeline / Security
**Related:** ADR-005-1, ADR-005-2

## Context and Problem Statement

While Blueprints are immutable, **Connector Instances** are live configurations bound to a distribution. The instantiation process is critical and dangerous:

1. **Secrets:** User-supplied passwords/tokens must *never* be stored in the database in plain text.
2. **Integrity:** We must ensure the linked `Distribution` exists in the Catalog.
3. **Atomicity:** The creation process involves multiple systems (Vault, DB, Catalog). We need a "Dry Run" capability to validate configuration without side effects.
4. **Idempotency:** Re-instantiating a connector for an existing distribution should result in an orderly update (Upsert) rather than a duplicate error.

## Decision

We will implement a **ConnectorManager** service that acts as a facade for the entire instantiation lifecycle.

1. **Vault Integration:** Arguments defined as `ParameterType::Secret` are intercepted. The Manager writes them to **Hashicorp Vault** and replaces the value in the configuration object with a `VaultRef` (path + key).
2. **Dry Run Mode:** A flag in the input DTO allows running the entire validation pipeline (Type checks, Catalog existence) without performing Vault writes or DB inserts.
3. **Audit Logging:** All state changes are recorded in a `connector_events` table.

## Detailed Design

### 1. Instantiation DTO

The input DTO separates the logical template reference from the concrete configuration values.

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectorInstantiationDto {
    /// Link to the Blueprint (Name+Version OR UUID)
    #[serde(flatten)]
    pub template_ref: TemplateReference,

    /// Link to the DCAT Distribution
    pub distribution_id: Uuid,

    /// Concrete values for the parameters defined in the Blueprint
    pub arguments: HashMap<String, serde_json::Value>,

    /// Metadata for the instance (owner, description)
    pub metadata: Option<InstanceMetadataDto>,

    /// If true, validates only. No side effects.
    #[serde(default)]
    pub dry_run: bool,
}

```

### 2. Orchestration Flow

The Manager executes the following pipeline:

1. **Fetch Template:** Retrieve the `ConnectorTemplate` from DB.
2. **Validate Distribution:** Query Catalog Facade to ensure `distribution_id` exists.
3. **Validate Arguments:** Use the Logic from ADR-005-2 to ensure `arguments` match `parameters`.
4. **Handle Secrets (Real Mode only):**
* Iterate over `arguments`.
* If argument corresponds to a `SECRET` parameter:
* Write content to Vault (path: `/connectors/{dist_id}`).
* Replace value in memory with `{ "type": "VAULT_REF", "content": ... }`.




5. **Persist (Real Mode only):**
* Perform Upsert on `connector_instances` table.
* Insert `INIT` event into `connector_events`.



### 3. Database Schema (Instance & Events)

We store the *resolved* configuration (with Vault Refs) in `connector_instances`.

```rust
// Connector Instances Table
manager.create_table(
    Table::create()
        .table(ConnectorInstances::Table)
        .col(ColumnDef::new(ConnectorInstances::Id).string().not_null().primary_key())
        .col(ColumnDef::new(ConnectorInstances::TemplateId).string().not_null())
        .col(ColumnDef::new(ConnectorInstances::DistributionId).string().not_null())
        .col(ColumnDef::new(ConnectorInstances::CurrentState).string().default("INIT"))
        // Stores the configuration with secrets replaced by Vault Refs
        .col(ColumnDef::new(ConnectorInstances::ConfigurationValues).json_binary().not_null())
        .foreign_key(
            ForeignKey::create()
                .from(ConnectorInstances::Table, ConnectorInstances::TemplateId)
                .to(ConnectorTemplates::Table, ConnectorTemplates::Id)
        )
        .to_owned()
).await?;

// Connector Events Table (Audit)
manager.create_table(
    Table::create()
        .table(ConnectorEvents::Table)
        .col(ColumnDef::new(ConnectorEvents::Id).string().primary_key())
        .col(ColumnDef::new(ConnectorEvents::ConnectorInstanceId).string().not_null())
        .col(ColumnDef::new(ConnectorEvents::EventType).string().not_null()) // STATE_CHANGE, ERROR
        .col(ColumnDef::new(ConnectorEvents::Payload).json_binary())
        .foreign_key(
             ForeignKey::create()
                .from(ConnectorEvents::Table, ConnectorEvents::ConnectorInstanceId)
                .to(ConnectorInstances::Table, ConnectorInstances::Id)
                .on_delete(ForeignKeyAction::Cascade)
        )
        .to_owned()
).await?;

```
